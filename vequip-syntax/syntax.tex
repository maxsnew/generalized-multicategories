\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{tikz-cd}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{bbm}

\DeclareMathOperator*{\colim}{colim}

\begin{document}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{construction}{Construction}
\newtheorem{definition}{Definition}
\newcommand{\pto}{\nrightarrow}
\newcommand{\pfrom}{\nleftarrow}
\newcommand{\vcat}{\mathcal}
\newcommand{\cat}{\mathbbm}
\newcommand{\vtkmnd}{\mathbb{K}\text{Mod} (\vcat{V},T)}
\newcommand{\rmod}{\text{RMod}}
\newcommand{\lmod}{\text{LMod}}

\newcommand{\id}{\textrm{id}}
\newcommand{\for}{\textrm{for}\,}
\newcommand{\when}{\textrm{when}\,}
\newcommand{\lett}{\textrm{let}\,}
\newcommand{\sort}{\,\,\textrm{sort}}
\newcommand{\ctx}{\,\,\textrm{context}}
\newcommand{\prof}{\,\,\textrm{span}}
\newcommand{\subst}{\,\,\textrm{subst}}
\newcommand{\sigctx}{\,\,\textrm{sig-ctx}}
\newcommand{\sig}{\,\,\textrm{sig}}
\newcommand{\pipe}{\mathrel{|}}

\title{Judgment Theory: A Syntax for Virtual Equipments with applications to Internal and Synthetic Theory}
\author{Max S. New}

\maketitle

\begin{abstract}
  We present a formal type theory for Virtual Equipments we call
  Judgment Theory. Virtual equipments are known as a ``good place to
  do category theory'', i.e. an alternative to 2-categories for doing
  formal category theory where profunctors/distributors and their
  morphisms are as fundamental as functors and natural
  transformations. We show 2 different applications of judgment
  theory. First, we can do \emph{internal category theory}, defining
  categories in a virtual equipment and prove some basic lemmas about
  them, such as the equivalence between the definition of adjoint
  functors in terms of hom-set isomorphism and universal
  morphism. Second, we can do \emph{synthetic} category theory by
  defining synthetic notions of Hom set and tensor/cotensor of
  profunctors.
\end{abstract}

\section{Introduction}

In what follows we present an internal language for virtual equipments
(TODO: cite Crutwell-Shulman, Leinster, Hermida)
%
Despite sounding slightly obscure, virtual equipments are quite useful
as ``a good place to do category theory'', that is a virtual equipment
has enough structure to define internal notions of category,
multicategory and polycategory.
%% %
%% From a type-theoretic angle and a sprinkle of Curry-Howard-Lambek
%% ideology, we can also see a virtual equipment as a ``good place to
%% study type theories'' and so we call the type theory ``judgment
%% theory''.

\section{Syntax}

\subsection{Judgments}
The following figures present the basic formation, primitive and
admissible and equality rules of our type theory, an internal language
for virtual equipments.
%
Note that contra Crutwell-Shulman, we define a virtual equipment to be
a virtual double category with all restrictions, whereas they
additionally require the category to have all \emph{units}.
%
The type theory has 4 central concepts, which we will refer to
sometimes using type theoretic/set theoretic and at other times
category-theoretic terminology.
%
In type theoretic terminology, judgment theory has \emph{sorts} $\cat
C, \cat D, \cat E$, and \emph{types} $A,B,C$ which have a given sort
and are also \emph{parameterized} by an object of some other sort, and
so can also be thought of as \emph{functions} with input and output
sorts.
%
Next there are \emph{judgments} $P,Q,R,S$ which are parameterized by
two variables.
%
In $\alpha^o:\cat C;\beta : \cat D \pipe R$, we say $R$ depends on
$\alpha$ \emph{contravariantly} and in $\beta$ \emph{covariantly}.
%
Finally, we have \emph{terms} $s,t,u$ that are elements of some
judgment $R$ but are also parameterized by elements of some other
judgments which are given by a \emph{context} $\Phi$, which is a
``compatible string'' of judgments where the covariant variable of one
judgment is the same as the contravariant variable of the next.
%
Since these terms are parameterized by other terms, we can see these
as \emph{inference rules} for the judgments.

At other times we will want to think of these using set-theoretic
terminology, in which case we have sets $\cat C,\cat D, \cat E$,
functions/elements $A,B,C$, \emph{spans} $R,\ldots$ and morphisms of
spans $s,t,u$.
%
Finally when we develop multicategory theory we will use
category-theoretic terminology, in which the structure is most
familiar and we have categories, objects/functors,
\emph{profunctors}/bimodules and 2-cells/homomorphisms of bimodules.

\begin{figure}
  \begin{mathpar}
    \cat C \sort\\
    \inferrule*[right=Object/Type-formation]
    {\cat C \sort \and \cat D \sort}
    {\alpha : \cat C \vdash A : \cat D}\\

    \inferrule*[right=Relation/Judgment/Profunctor-formation]
    {\cat C \sort \and \cat D \sort}
    { R \prof(\alpha^{o}:\cat C; \beta : \cat D)}

    \inferrule*[right=Context-formation]
    {\cat C \sort \and \cat D \sort}
    {\Phi \ctx(\alpha^o:\cat C;\beta:\cat D)}

    \inferrule*[right=Element/Term/Arrow-formation]
    {\Phi \ctx(\alpha^o:\cat C; \beta : \cat D)\and
      R \prof(\alpha^o:\cat C; \beta : \cat D)}
    {\Phi \vdash t : R}

    \inferrule*[right=Substitution-formation]
    {\Phi \ctx(\alpha^o:\cat C;\beta:\cat D) \and \Psi \ctx(\alpha'^o:\cat C';\beta':\cat D')\\\\
      \alpha:\cat C \vdash A : \cat C' \and \beta : \cat D \vdash B : \cat D'
    }
    {\psi : \Phi\vdash \Psi \subst(A/\alpha';B/\beta')}
  \end{mathpar}
  \caption{Formation Rules of Judgment Theory}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule*[right=ObVar]
    {~}
    {\alpha : \cat C \vdash \alpha : \cat C}

    \inferrule*[right=ObSubst*]
    {\alpha : \cat C \vdash B : \cat D\and
    \beta : \cat D \vdash A : \cat E}
    {\alpha : \cat C \vdash A[B/\beta] : \cat E}\\

    \inferrule*[right=SpanRestriction*]
    {R\prof(\alpha^o : \cat C;\beta : \cat D) \and
      \alpha' : \cat C' \vdash A : \cat C\and
      \beta' : \cat D' \vdash B : \cat D'}
    {R[A/\alpha,B/\beta] \prof(\alpha'^o : \cat C';\beta':\cat D')}\\\\

    \inferrule*[right=MtCtx]
    {\cat C \sort}
    {\alpha : \cat C}

    \inferrule*[right=CtxExt]
    {\Phi \ctx(\alpha^o : \cat C; \beta : \cat D)\and
      R \prof(\beta^o : \cat D; \gamma : \cat E)}
    {\Phi,x : R, \gamma : \cat E \ctx(\alpha^o : \cat C ; \gamma : \cat E)}

    \inferrule*[right=CtxTensor*]
    {\Phi(\alpha^o : \cat C; \beta : \cat D) \and
    \Psi \ctx(\beta^o : \cat D; \gamma : \cat E)}
    {\Phi, \Psi\ctx(\alpha^o : \cat C; \gamma : \cat E)}\\\\

    \inferrule*[right=TransVar]
    {~}
    {\alpha : \cat C, x : R, \beta : \cat D \vdash x : R}
    
    \inferrule*[right=TransSubst*]
    {\psi : \Phi \vdash \Psi \subst(A/\alpha;B/\beta) \and
    \Psi \vdash t : R}
    {\Phi \vdash t[\psi] : R[A/\alpha;B/\beta]}\\\\

    \inferrule*[right=TransSubstMt]
    {\alpha : \cat C \vdash B : \beta}
    {B : (\alpha : \cat C) \vdash (\beta : \cat D) \subst(B/\beta;B/\beta)}

    \inferrule*[right=TransSubstExt]
    {\psi : \Phi \vdash \Psi \subst(A/\alpha;B/\beta) \and
     \Phi' \vdash t : R[B/\beta;\Gamma/\gamma]}
    {\psi, t, \Gamma : \Phi,\Phi' \vdash \Psi, x:R, \gamma : \cat E \subst(A/\alpha;\Gamma/\gamma)}

    \inferrule*[right=TransSubstTensor*]
    {\psi : \Phi \vdash \Psi \subst(A/\alpha;B/\beta)\and
     \psi' : \Phi' \vdash \Psi' \subst(B/\beta;\Gamma/\gamma)}
    {\psi,\psi' : \Phi,\Phi' \vdash \Psi,\Psi' \subst(A/\alpha;\Gamma/\gamma)}
    \\\\
  \end{mathpar}
  \caption{Basic Rules of Judgment Theory, starred rules are
    admissible, non-starred are primitive}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \begin{array}{rcl}
      A[\alpha/\alpha] &=& A\\
      A[B/\beta][C/\gamma] & = & A[B[C/\gamma]/\beta]\\\\
      
      R[\alpha/\alpha,\beta/\beta] &=& R\\
      R[\alpha'.A/\alpha,\beta'.B/\beta][A'/\alpha',B'/\beta'] & = &
      R[A[A'/\alpha']/\alpha,B[B'/\beta']/\beta]\\\\
      \Phi,\cdot &=& \Phi\\
      \cdot,\Phi &=& \Phi\\
      (\Phi,\Psi),\Theta &=& \Phi,(\Psi,\Theta)\\\\
      (\phi,\chi),\psi &=& \phi, (\chi, \psi)\\\\
      t[\alpha_0,x_0,\ldots,\alpha_n] &=& t\\
      TODO: associativity
      %% t[\Psi_1.s_1/\phi_1,\ldots,\Psi_n.s_n/\phi_n][\vec u_1/\Psi_1,\ldots,\vec u_n/\Psi_n] &=& t[s_1[\vec u_1/\Psi_1]/\phi_1,\ldots,s_n[\vec u_n/\Psi_n]/\phi_n]\\
    \end{array}
  \end{mathpar}  
  \caption{Algebraic Properties of Basic Rules}
\end{figure}

\subsection{Multiplicatives}

Now that we have established the central judgments and their algebraic
structure, we can study connectives that internalize this judgmental
structure. The ``monoidal'' part of the structure here is the
structure of the term context $\phi$, which includes the empty context
$\cdot_{\alpha}$ as unit and concatenation as ``product''.  We
correspondingly can add multiplicative connectives to the syntax that
internalize $\cdot$ and comma.

First, to internalize $\cdot_{\alpha : \cat C}$ we can define the
\emph{hom judgment} $A \to_{\cat C} A'$, which in set-theoretic
settings we might call the \emph{identity/equality judgment}
$A \equiv_{\cat C} A'$.
%
First the formation rule says given two objects $A,A'$ in the same
category $\cat C$, we can form the hom-set from $A$ to $A'$.
%
The introduction rule says that given any object $A$, we can define
the identity arrow from $A$ to itself.
%
Without knowing more about the category in question, these are the
only arrows we know exist.
%
Next the elimination form says that to define a term whose input is a
morphism $f : \beta \to_{\cat C} \beta'$, we need only define how it
is behaved on the identity function.
\begin{mathpar}
    \inferrule*[right=Hom-Formation]
    {\beta : \cat D \vdash A : \cat C\and
    \gamma : \cat E \vdash A' : \cat C}
    {\beta^o : \cat D;\gamma : \cat E \pipe A \to_{\cat C} A'}

    (A \to A')[B/\alpha;B'/\beta] = (A[B/\alpha] \to A'[B'/\beta])

    \inferrule*[right=Hom-Introduction]
    {\alpha : \cat D \vdash A : \cat C}
    {\alpha^o : \cat D, \alpha : \cat D | \cdot \vdash \id_{A} : A \to_{\cat C} A}

    \id_{A}[B/\alpha] = \id_{A[B/\alpha]}

    \inferrule*[right=Hom-Left (Sequent Style)]
    {\alpha^o,\beta|\Phi,\phi : R[\delta/\delta_1], \psi : S[\delta/\delta_2],\Psi \vdash Q }
    {\alpha^o,\beta|\Phi,\phi : R, \chi : \delta_1 \to \delta_2, \psi : S,\Psi \vdash Q}
    
    \inferrule*[right=Hom-Elim]
    {\beta_1^o;\beta_2\pipe\Psi \vdash f : \beta_1 \to_{C} \beta_2\and
      \alpha^o;\beta\pipe \Phi\and
      \beta^o;\gamma\pipe \Phi'\and
      \Phi,\Phi' \vdash g : R}
    {\Phi[\cdot;\beta_1/\beta],\Psi,\Phi'[\beta_2/\beta;\cdot]\vdash \when f = \id_{\beta}.~ g : R[\beta_1/\beta;\beta_2/\beta]}

    (\when f = \id_{\beta}. g)[l,m,r] = \when f[m] = \id_{\beta}. g[l,r] \textrm{TODO: dig into this}
    
    \when \id_{\alpha} = \id_{\beta}.~ g \equiv g[\alpha/\beta]

    \inferrule*[right=Hom-$\eta$]
    {...}
    {\beta_1^o : \cat C;\beta_2:\cat C\pipe \Phi \vdash f \equiv \when f = \id_{\alpha} .~ \id_{\alpha} : \beta_1 \to_{\cat C} \beta_2}
\end{mathpar}

Next, we can internalize the $,$ in judgment contexts in one of two
ways: on the left as a tensor product or on the right as a power.


Next, let's define the tensor product of profunctors, also known as
the \emph{composition} of profunctors.
\begin{mathpar}
  \inferrule*[right=Tensor formation]
  {\alpha^o : \cat C; \beta : \cat D \pipe Q \and \beta^o : \cat D; \gamma : \cat E \pipe R}
  {\alpha^o : \cat C; \gamma : \cat E \pipe \exists \beta.~Q \odot R}

  \inferrule*[right=Tensor introduction]
  {\Phi \vdash M : Q[B/\beta] \and \Psi \vdash N : R[B/\beta]}
  {\Phi,\Psi\vdash (B,M,N) : \exists \beta. Q \odot R}

  \inferrule*[right=Tensor elimination]
  {\Psi \vdash M : \exists \beta. Q \odot R \and \Phi,x:Q,y:R,\Phi' \vdash N : P}
  {\Phi,\Psi,\Phi' \vdash \lett (\beta,x,y) = M.~N : P}

  (\lett (\beta,x,y) = (B,M_l,M_r).~ N) = N[B/\beta][M_l/x][M_r/y]\\

  N = \lett(\beta, x,y) = z.~ N[(\beta, x,y)/z]
\end{mathpar}
First, the syntax for tensor is based on the coend formula that gives
the definition in $Cat$, but using logical syntax $\exists$ rather
than integrals because I don't like integral syntax and the syntax
matches existential quantification in type theory.
%
Note that $\exists \beta. ~Q \odot R$ is the application of a single
connective to $Q$ and $R$, and not separable into a quantifier
$\exists$ connective and a product connective $\odot$.
%
Introduction, elimination and $\beta\eta$ are similar to a combination
of existential quantification and the tensor product in linear logic.

Finally, we can define \emph{cotensor} products of profunctors, which
is the internal-hom to tensor products product. Since we are in an
ordered setting, this splits into two connectives: a right-cotensor
and a left cotensor. NOTE/TODO: one of these cotensor elimination
rules breaks the syntactic invariant that all variable occurrences go
from left to right syntactically. Should we fix or abandon that
invariant?
\begin{mathpar}
  \inferrule*[right=Covariant Cotensor formation]
  {\beta^o : \cat D; \gamma : \cat E \pipe R \and \alpha^o : \cat C; \gamma : \cat E \pipe P}
  {\alpha^o : \cat C; \beta : \cat D \pipe \forall \gamma.~ P \triangleleft R}

  \inferrule*[right=Covariant Cotensor introduction]
  {\Phi , x : R \vdash M : P}
  {\Phi \vdash \lambda^\triangleleft (\gamma,x). M : \forall \gamma.~ P \triangleleft R}

  \inferrule*[right=Covariant Cotensor elimination]
  {\Phi \vdash M : \forall \gamma.~P\triangleleft R \and \Psi \vdash N : R[B/\gamma]}
  {\Phi, \Psi \vdash M(B,N)^{\triangleleft} : P[B/\gamma]}

  (\lambda (\gamma,x). M)(B,N) = M[B/\gamma][N/x]\\
  M = \lambda^\triangleleft (\gamma,x). M(\gamma,x)\\

  \inferrule*[right=Contravariant Cotensor formation]
  {\alpha^o : \cat C; \beta : \cat D \pipe Q \and \alpha^o : \cat C; \gamma : \cat E \pipe P}
  {\beta^o : \cat D; \gamma : \cat E \pipe \forall \alpha.~ Q \triangleright P}

  \inferrule*[right=Contravariant Cotensor introduction]
  {x:Q,\Phi \vdash M : P}
  {\Phi \vdash \lambda^\triangleright(\alpha,x). M : \forall \alpha.~Q\triangleright P}

  \inferrule*[right=Contravariant Cotensor elimination]
  {\Phi \vdash M : \forall \alpha. Q \triangleright P \and \Psi \vdash N : Q[A/\alpha]
  }
  {\Psi,\Phi \vdash M(A,N)^\triangleright : P[A/\alpha]}

  (\lambda^\triangleright (\alpha,x). M)(A,N)^\triangleright = M[A/\alpha][N/x]\\
  M = \lambda^\triangleright (\alpha, x). M(\alpha,x)^\triangleright
\end{mathpar}

\subsection{Additives}

Next, we consider what we need to do to add additive connectives.
%
Since we have two category-like structures (types/functors and
terms/transformations) we can define additive connectives for each of
their objects: sorts and judgments.
%
These seem to be entirely independent constructions: we can define the
product of sorts and we can separately define the product of judgments
and neither relies on the other existing.

\begin{figure}
  \begin{mathpar}
    \inferrule{~}{1 \sort}

    \inferrule*[right=1-Ty-Intro]{~}{\alpha : C \vdash () : 1}

    \inferrule*[right=1-Ty-$\eta$]{\alpha : C \vdash A : 1}{\alpha : C \vdash A = () : 1}\\

    \inferrule{~}{\alpha^o:C;\beta:D \pipe 1}

    \inferrule*[right=1-Tm-Intro]{~}{\Phi \vdash () : 1}
    
    \inferrule*[right=1-Tm-$\eta$]{\Phi \vdash t : 1}{\Phi \vdash t = () : 1}\\

    ()[\gamma] = ()\and 1[A/\alpha;B/\beta] = 1 \and ()[\phi] = ()
  \end{mathpar}
  \caption{Terminal Sort, Judgment}
\end{figure}

\begin{figure}
  \begin{mathpar}
    
    \inferrule{C \sort \and D\sort}{C \times D \sort}

    \inferrule
    {\alpha : C \vdash A_1 : D_1 \and \alpha : C \vdash A_2 : D_2}
    {\alpha : C \vdash (A_1,A_2) : D_1 \times D_2}

    (A_1,A_2)[B/\alpha] = (A_1[B/\alpha], A_2[B/\alpha])
     
    (\pi_i A)[B/\alpha] = \pi_i A[B/\alpha]

    \inferrule{\alpha : C \vdash A : D_1 \times D_2}{\alpha : C \vdash \pi_i A : D_i}

    \inferrule*[right=$\times-\beta$]{~}{\pi_i(A_1,A_2) = A_i}

    \inferrule*{\alpha : C \vdash A : D_1 \times D_2}{\alpha : C \vdash A = (\pi_1 A, \pi_2 A) : D_1\times D_2}\\

    \inferrule
    {\alpha^o: C;\beta : D \pipe R_1 \and \alpha^o: C;\beta : D \pipe R_2}
    {\alpha^o: C;\beta : D \pipe R_1 \times R_2}

    (R_1 \times R_2)[A/\alpha;B/\beta] = (R_1[A/\alpha;B/\beta] \times R_2[A/\alpha;B/\beta])

    \inferrule
    {\Phi \vdash t_1 : R_1 \and \Phi \vdash t_2 : R_2}
    {\Phi \vdash (t_1,t_2) : R_1 \times R_2}

    (t_1,t_2)[\phi] = (t_1[\phi], t_2[\phi])

    \inferrule
    {\Phi \vdash u : R_1 \times R_2}
    {\Phi \vdash \pi_i u : R_i}

    (\pi_i u)[\phi] = \pi_i u[\phi] 

    \inferrule{~}{\pi_i (t_1,t_2) = t_i}

    \inferrule{\Phi \vdash t : R_1 \times R_2}{t = (\pi_1 t, \pi_2 t)}
  \end{mathpar}
  \caption{Product Sort, Judgment}
\end{figure}

To define internal ends and coends, we need to go beyond the usual
simple types and add equalizers (a form of subsets) and co-equalizers
(a form of quotients) of judgments. Here's a sketch of the syntax for
each. These make type checking very difficult as they result in
obligations for proving equality of certain terms, which may or may
not be decidable.

\begin{mathpar}
  \inferrule*[right=Equalizer Formation]
  {\alpha;\beta\,|\, R \and
  x : R \vdash t : S x:R \vdash u : S}
  {\alpha;\beta\,|\,\{ x : R \,|\, t = u \}}

  \inferrule*[right=Equalizer Intro]
  {\Phi \vdash r : R \and t[r/x] = u[r/x]}
  {\Phi \vdash \textrm{assert}(x.t = u)(r) : \{ x : R \,|\, t = u \}}

  \inferrule*[right=Equalizer Elim]
  {\Phi \vdash r : \{ x : R \,|\, t = u \}}
  {\Phi \vdash \textrm{forget}(r) : R}

  t[\textrm{forget}(r)/x] = u[\textrm{forget(r)}/x]

  \textrm{assert}(x.t = u)(\textrm{forget}(r)) = r
  \textrm{forget}(\textrm{assert}(x.t = u)(r)) = r
\end{mathpar}

\begin{mathpar}
  \inferrule*[right=Co-equalizer Formation]
  {\alpha;\beta\,|\, R \and
  x : S \vdash t : R x:S \vdash u : R}
  {\alpha;\beta\,|\,R/(\forall x:S. t = u)}

  \inferrule*[right=Coequalizer Intro]
  {\Phi \vdash r : R}
  {\Phi \vdash \textrm{equate}(x:S.t=u)(r) : R/(\forall x.t=u)}

  \inferrule*[right=Coequalizer Elim]
  {\Psi \vdash r : R/(x.t = u) \and
    \Phi,y:R,\Phi' \vdash s : S \and
    s[t/y] = s[u/y]}
  {\Phi,\Psi,\Phi' \vdash \textrm{lett} \textrm{equate}(y) = r.~s : S}

  \textrm{equate}(x:S.t = u)(t[\gamma]) = \textrm{equate}(x:S.t = u)(u[\gamma])

  \cdots
\end{mathpar}

\section{Internal Category Theory}

Next, we introduce the notion of category internal to our syntactic
virtual equipment and the \emph{monoids and modules} translation that
shows that, with the inclusion of hom sets, our syntax is already
suitable for doing syntactic category theory.

The benefits of our syntax become clear when we define internal
categories, functors, profunctors and transformations: the definitions
read exactly as the classical definitions.
\begin{definition}[Internal Category]
  An \emph{(internal) category} consists of
  \begin{enumerate}
  \item A sort $\cat C_0$
  \item A span $\alpha^o:C_0;\alpha' : C_0 \pipe \alpha^o \to_{\cat C} \alpha'$
  \item Identity arrows $\alpha^o : C_0; \alpha : C_0 \pipe \cdot
    \vdash \id_{\alpha} : \alpha \to_{\cat C} \alpha$.
  \item Composition $\alpha_0^o:C_0;\alpha_2:C_0\pipe \phi_0 :
    \alpha_0 \to \alpha_1, \phi_1 : \alpha_1 \to \alpha_2 \vdash
    \phi_1 \circ \phi_0 : \alpha_0 \to \alpha_2$
  \item Satisfying Unitality:
    \[ \id_{\alpha} \circ \phi = \phi = \phi \circ \id_{\alpha'}\]
  \item And Associativity:
    \[ (\phi \circ \psi) \circ \theta = \phi \circ (\psi \circ \theta) \]
  \end{enumerate}
\end{definition}

\begin{definition}[Internal Functor]
  A functor $F$ between internal categories $\cat C$ and $\cat D$ consists of
  \begin{enumerate}
  \item a function on objects $\alpha : \cat C_0 \vdash F_0 : \cat D_0$
  \item a function on arrows $\alpha_0^o : \cat C_0; \alpha_1 : \cat C_0\pipe \phi:\alpha_0 \to_{\cat C} \alpha_1 \vdash F_1(\phi) : F_0(\alpha_0) \to_{\cat D} F_0(\alpha_1)$
  \item that preserves identity:
    \[ F_1(\id_{\alpha}) = \id_{F_0(\alpha)}\]
  \item and composition:
    \[ F_1(\psi \circ \phi) = F_1(\psi) \circ F_1(\phi) \]
  \end{enumerate}
\end{definition}

\begin{definition}[Internal Profunctor]
  A profunctor $R$ between internal categories $\cat C$ and $\cat D$
  consists of
  \begin{enumerate}
  \item A span $\alpha^o : \cat C_0\pipe \beta : \cat D_0 \pipe \alpha \to_{R} \beta$
  \item $C$-composition: $\alpha_0^o:\cat C_0;\beta : \cat D_0\pipe \phi : \alpha_0 \to_{C} \alpha_1, \psi : \alpha_1 \to_{R} \beta \vdash \psi \circ_{R\cat C} \phi : \alpha_0 \to_{R} \beta$
  \item $D$-composition: $\alpha^o:\cat C_0;\beta_1 : \cat D_0\pipe \psi : \alpha \to_{R} \beta, \theta : \beta_0 \to_{\cat D} \beta_1 \vdash \theta \circ_{\cat DR} \psi : \alpha \to_{R} \beta_1$
  \item Satisfying $\cat C$ associativity: $\psi \circ_{R\cat C} (\phi_1 \circ_{\cat C} \phi_0) = (\psi \circ_{R\cat C} \phi_1) \circ_{R\cat C} \phi_0$
  \item Satisfying $\cat C$ unitality: $\psi \circ_{R\cat C} \id_{\alpha} = \psi$
  \item Satisfying $\cat D$ associativity: $(\theta_1 \circ_{\cat D} \theta_0) \circ_{\cat DR} \psi = \theta_1 \circ_{\cat D R} (\theta_0 \circ_{\cat DR} \psi)$
  \item Satisfying $\cat D$ unitality: $\id_{\beta} \circ_{\cat D R} \psi = \psi$
  \item Satisfying mixed associativity: $(\theta \circ_{\cat D R} \psi) \circ_{R \cat C} \phi = \theta \circ_{\cat D R} (\psi \circ_{R \cat C} \phi)$
  \end{enumerate}
\end{definition}

Next, we show that Profunctors can be restricted by functors

\begin{definition}[Restriction of Profunctors]
  If $\cat C, \cat D, \cat C', \cat D'$ are categories, and $\alpha' :
  \cat C' \vdash F[\alpha'] : \cat C$ and $\beta' : \cat D' \vdash
  G[\beta'] : \cat D$ are functors and $\alpha^o : \cat C;\beta : \cat
  D \pipe \alpha^o \to_{R} \beta$ is a profunctor, then $F[\alpha']
  \to_{R} G[\beta']$ is given the structure of a profunctor by:
  \begin{enumerate}
  \item $\cat C'$ composition:
    \[ \phi : \alpha_0 \to_{\cat C'} \alpha_1, \psi : F[\alpha_1] \to_{R} G[\beta] \vdash \psi \circ_{R\cat C} F_1[\phi] : F[\alpha_1] \to_{R} G[\beta]
    \]
  \item $\cat D'$ composition:
    \[ \alpha^o:\cat \cat C';\beta_1 : \cat D'\pipe \psi : F[\alpha] \to_{R} G[\beta], \theta : \beta_0 \to_{\cat D'} \beta_1 \vdash G[\theta] \circ_{\cat DR} \psi : F[\alpha] \to_{R} G[\beta_1] \]
  \end{enumerate}
\end{definition}

\begin{definition}[Natural Transformation]
  A transformation $F : \Phi \vdash : R$ where each of the sorts in
  $\alpha^o: \cat C;\beta : \cat D \pipe \Phi$ has a given category
  structure and each of the spans in $\Phi$ has a profunctor structure
  on those category structures is given by
  \begin{enumerate}
  \item A function $\Phi \vdash F_1 : \alpha \to_{R} \beta$
  \item Internal Naturality: For any decomposition $\Phi = \Phi_0,\phi
    : \gamma \to_{S} \delta,\psi : \delta \to_{T} \epsilon,\Phi_1$
    where $\gamma : \cat E$ and $\delta : \cat F$, $\epsilon : \cat
    G$, an equality
    \[ \Phi_0,\phi : \gamma\to_{S} \delta_0, \theta : \delta_0 \to_{\cat F} \delta_1,\psi : \delta_1\to_T \epsilon, \Phi_1 \vdash F_1[\theta \circ_{\cat F S} \phi/\phi] = F_1[\psi \circ_{T \cat F}\theta /\psi] \]
  \item Left naturality: If $\Phi = \phi : \alpha \to_{s} \gamma,\Phi'$
    then \[ F_1 \circ_{R\cat C} \psi = F_1[\phi \circ_{S\cat C} \psi]\]
  \item Right naturality: If $\Phi = \Phi', \phi : \gamma \to_{S}
    \beta$, then
    \[ \phi \circ_{\cat D R} F_1 = F_1[\psi \circ \phi/\psi]\]
  \end{enumerate}
\end{definition}

This last definition is probably unfamiliar to the reader that is not
experienced with profunctors.
%
However, we can show that the traditional definition is equivalent to
a natural transformation $\alpha : \cat C_0 \pipe \cdot \vdash
t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha')$.

\begin{definition}[Traditional Natural Transformation]
  A traditional natural transformation from $\alpha : \cat C_0 \vdash
  F(\alpha) : \cat D_0$ to $\alpha : \cat \vdash G(\alpha') : \cat
  D_0$ consists of
  \begin{enumerate}
  \item A term $\cdot \vdash t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha)$
  \item Such that
    \[ \phi : \alpha \to_{\cat C} \alpha' \vdash t_{\alpha'} \circ F_1(\phi) \equiv G_1(\phi) \circ t_{\alpha} : F(\alpha) \to_{\cat D} G(\alpha')
    \]
  \end{enumerate}
\end{definition}

\begin{theorem}[Equivalent Presentations of Natural Transformations]
  There is a bijection between traditional natural transformations $t
  : F \to G$ and profunctor homomorphisms $h : \alpha \to_{\cat C}
  \alpha' \vdash F(\alpha) \to_{\cat D} G(\alpha')$ given by
  \begin{enumerate}
  \item From a natural transformation $t$ we define a homomorphism
    $h(t)$ by composing on the $F$ side. The choice of this side is
    arbitrary and we could just as easily have used $G$ since they are
    equal by naturality.
    \[ \phi : \alpha \to_{\cat C} \alpha' \vdash t_{\alpha'} \circ F_1(\phi) : F(\alpha) \to_{\cat D} G_1(\alpha') \]
  \item From a homomorphism $\phi.h$, we define a natural transformation $t(h)$ as
    \[ \alpha \pipe \cdot \vdash h[{\id_{\alpha}}/\phi] \]
  \end{enumerate}
\end{theorem}
\begin{proof}
  First we show that the maps $h(\cdot),t(\cdot)$ actually produce
  homomorphisms and natural transformations.
  \begin{enumerate}
  \item On the left, we need to show $h(t)_{\phi} \circ F_1(\psi) =
    h(t)_{|phi \circ \psi}$. Expanding the definition, we just need
    associativity and functoriality of $F_1$:
    \begin{align*}
      h(t)_{\phi} \circ F_1(\psi) &\equiv (t_{\alpha'} \circ F_1(\phi)) \circ F_1(\psi)\\
      &\equiv t_{\alpha'} \circ F_1(\phi \circ \psi)\\
      &\equiv h(t)_{\phi \circ \psi}
    \end{align*}
    on the right, we use naturality:
    \begin{align*}
      G_1(\theta) \circ h(t)_{\phi} &\equiv G_1(\theta) \circ (t_{\alpha'} \circ F_1(\phi))\\
      &\equiv (t_{\alpha''} \circ F_1(\theta)) \circ F_1(\phi)\\
      &\equiv t_{\alpha''} \circ F_1(\theta \circ \phi)\\
      &\equiv t_{\theta \circ \phi}
    \end{align*}
  \item In the other direction, to prove naturality:
    \begin{align*}
      h[\id_\alpha/\phi] \circ F_1(\psi) &\equiv h[\id_\alpha \circ \psi/\phi]\\
      &\equiv h[\psi/\phi]\\
      &\equiv h[\psi \circ \id_{\alpha'}/\phi]\\
      &\equiv G_1(\psi) \circ h[\id_{\alpha}/\phi]
    \end{align*}
  \end{enumerate}
  Next we seek to prove that the functions are mutually inverse.
  \begin{enumerate}
  \item Round trip for homomorphisms:
    \begin{align*}
      h(t(h))_{\phi} &= t(h)_{\alpha} \circ F_1[\phi]\\
      &= h[\id_{\alpha}] \circ F_1[\phi]\\
      &= h[\id \circ \phi]\\
      &= h[\phi]
    \end{align*}
  \item Round trip for natural transformations uses the fact that
    functors preserve identity.
    \begin{align*}
      t(h(t))_{\alpha} &= h(t)_{\id_{\alpha}}\\
      &= t_{\alpha} \circ F_1[\id_{\alpha}]\\
      &= t_{\alpha} \circ \id_{F_0\alpha}\\
      &= t_{\alpha}
    \end{align*}
  \end{enumerate}
\end{proof}

\subsection{Universal Properties, Internally}

In a sense, the very purpose of category theory is to study universal
properties and so it is essential that our syntax provide a nice
presentation of universal properties.

Fortunately, the central placement of spans/profunctors in our syntax
makes the definition of a functor satisfying a universal property very
natural (should I introduce the unit category earlier?).

This is closest to the definition of adjoint functors by natural
isomorphism of hom-sets.
\begin{definition}[Right Representability]
  Let $\cat C, \cat D$ be categories and $\alpha^o : \cat C;\beta :
  \cat D \pipe \alpha \to_{Q} \beta$ be a profunctor between them. Then a \emph{right
    representation} of $Q$ consists of
  \begin{enumerate}
  \item A functor $\beta : \cat D \vdash G[\beta] : \cat C$
  \item An ``introduction rule'' homomorphism $\phi: \alpha \to_{Q}
    \beta \vdash I_G[\phi] : \alpha \to_{\cat C} G[\beta]$.
  \item An inverse homomorphism $\psi: \alpha \to_{\cat C} G[\beta]
    \vdash I_G^{-1}[\psi] : \alpha \to_{Q} \beta$. That is, it satisfies
    \begin{align*}
      I_G[I_G^{-1}[\psi]/\phi] &= \psi\\
      I_G^{-1}[I_G[\phi]/\psi] &= \phi
    \end{align*}
  \end{enumerate}
\end{definition}

While this is a fairly standard definition, it is likely unfamiliar to
type theorists, who may be surprised that Right Representability is
essentially the same as the definition of a negative type, which has
an introduction rule, but instead of an inverse, there is an
elimination rule, and the functoriality of the type is not primitive.
Fortunately, we can prove the equivalence between these notions
entirely syntactically.

\begin{definition}[Negative Type]
  A negative type (connective) $N$ between categories $\cat C$,$\cat D$ consists of
  \begin{enumerate}
  \item A judgment it represents $\alpha^o : \cat C;\beta : \cat D
    \pipe \alpha \to_{Q} \beta$
  \item A type $\beta : \cat D \vdash N[\beta] : \cat C$
  \item An ``introduction rule'' $\phi : \alpha \to_{Q} \beta \vdash
    I_N[\phi] : \alpha \to_{\cat C} N[\beta]$ that is a homomorphism
    \emph{on the left}:
    \[ \psi : \alpha' \to_{\cat C} \alpha, \phi : \alpha \to_{Q} \beta \vdash I_N[\phi] \circ_{\cat C} \psi \equiv I_N[\phi \circ_{Q} \psi] : \alpha' \to_{\cat C} N[\beta]\]
  \item An ``elimination rule'' $\beta^o:\cat D;\beta : \cat D \pipe
    \cdot \vdash \epsilon_{N}[\beta] : N[\beta] \to_{Q} \beta$
  \item Such that $\psi : \alpha \to_{\cat C} N[\beta] \vdash \epsilon_N[\beta]
    \circ_{Q} \psi : \alpha \to_{Q} \beta$ is an inverse to
    $I_{N}[\phi]$ in that
    \begin{align*}
       I_n[\epsilon_N[\beta] \circ \psi/\phi] &= \psi \tag{$\eta$}\\
      \epsilon_N[\beta] \circ I_n[\phi] &= \phi \tag{$\beta$}
    \end{align*}
  \end{enumerate}
\end{definition}

Part of this equivalence is the \emph{Yoneda Lemma}, which we state
now in its internal, parameterized form.
The usual non-parameterized Yoneda lemma can be formed if we have a
unit sort.

\begin{lemma}[Parameterized Yoneda Lemma]
  Given categories $\cat C, \cat D$ and a profunctor $\alpha^o:\cat
  C;\beta : \cat D \vdash \alpha \to_{Q} \beta$ and a function
  $\beta : \cat D \vdash G[\beta] : \cat C$, then there is an
  isomorphism between
  \begin{enumerate}
  \item Terms $\cdot \vdash t : G[\beta] \to_{Q} \beta$
  \item left-homomorphisms $\phi : \alpha \to_{\cat C} G[\beta] \vdash
    u : \alpha \to_{Q} \beta$ i.e. they satisfy homomorphism on the
    left (the other side doesn't make sense if $G$ is not a functor):
    $u[\phi \circ \psi] = u[\phi] \circ \psi$
  \end{enumerate}
\end{lemma}
\begin{proof}
  First, the constructions
  \begin{enumerate}
  \item Given $t$, we define $u(t)$ to be
    \[\phi : \alpha \to_{\cat C} G[\beta] \vdash t \circ_{Q} \phi : \alpha \to_{Q} \beta\]

    Which is a left-homomorphism because:
    \[ (t \circ_{Q} \phi) \circ_{Q} \psi = t \circ_{Q} (\phi \circ_{\cat C} \psi)\]
  \item Given $u$, we define $t(u)$ to be
    \[ \cdot \vdash u[\id_{G[\beta]}/\phi] : G[\beta] \to_{Q} \beta \]
  \end{enumerate}
  Now we show they are inverse
  \begin{enumerate}
  \item First, the very easy case, $\cdot \vdash t(u(t)) : G[\beta] \to_{Q} \beta$:
    \begin{align*}
      t \circ_{Q} \id_{G[\beta]} &= t
    \end{align*}
    by the fact that $Q$ is a profunctor.
  \item Next, $\phi : \alpha \to_{\cat C} G[\beta] \vdash u(t(u)) : \alpha \to_{Q} \beta$:
    \begin{align*}
      u[\id_{G[\beta]}/\phi] \circ_{Q} \phi &= u[\id \circ_{\cat C} \phi/\phi]\\
      &= u[\phi/\phi]\\
      &= u
    \end{align*}
    which uses the fact that $u$ is a left-homomorphism.
  \end{enumerate}
\end{proof}

\begin{theorem}[Negative Types and Right Representables are Equivalent]
  For any profunctor $\alpha^o: \cat C; \beta : \cat D \pipe \alpha
  \to_{Q} \beta$, there is a bijection between
  \begin{enumerate}
  \item Right Represntables $\beta : \cat D \vdash G[\beta] : \cat C$ for $Q$.
  \item Negative Types $\beta : \cat D \vdash N[\beta] : \cat C$
    representing $Q$.
  \end{enumerate}
\end{theorem}
\begin{proof}
  \begin{enumerate}
  \item Given a right representable $G[\beta]$, we set $N(G)[\beta] =
    G[\beta]$, the introduction rule is the same and the elimination
    rule is given as in the Yoneda lemma and the inverse property
    follows by the Yoneda isomorphism and the fact that $I_G^{-1}$ is
    an inverse for $I_G$.
  \item Given a negative type $N[\beta]$ we set $G(N)[\beta] =
    N[\beta]$, the introduction rule is the same and the inverse
    introduction rule is given as in the Yoneda lemma.  We need to
    show that $N[\beta]$ has the structure of a functor and that
    $I_{N}$ and $I_{N}^{-1}$ are homomorphisms on the right with
    respect to that structure.  Define $N_1$ as follows:
    \begin{mathpar}
      \inferrule
          {\beta_1^o:\cat D;\beta_2:\cat D \vdash \psi \circ \epsilon : N[\beta_1/\beta] \to_{Q} \beta_2\\
            \phi : N[\beta_1/\beta] \to_{Q} \beta_2 \vdash I_N[\phi] : N[\beta_1/\beta] \to_{\cat C} N[\beta_2/\beta]
          }
          {\beta_1^o:\cat D;\beta_2:\cat D\pipe \psi : \beta_1 \to_{\cat D} \beta_2 \vdash I_N[\psi \circ \epsilon_{\beta_1}/\phi] : N[\beta_1/\beta] \to_{\cat C} N[\beta_2/\beta]}
    \end{mathpar}
    We need to show functoriality.
    For identity we have
    \begin{align*}
      I_N[\id_{\beta} \circ \epsilon_{\beta}/\phi] &= I_N[\epsilon_{\beta}]\\
      &= I_N[\epsilon \circ \id_{N[\beta]}]\\
      &= \id_{N[\beta]} \tag{$\eta$}
    \end{align*}
    For composition,
    \begin{align*}
      N_1[\theta] \circ N_1[\psi]
      &= I_N[\theta \circ \epsilon] \circ I_N[\psi \circ \epsilon]\\
      &= I_N[(\theta \circ \epsilon) \circ I_N[\psi \circ \epsilon]]\tag{left homomorphism}\\
      &= I_N[\theta \circ (\epsilon \circ I_N[\psi \circ \epsilon])]\\
      &= I_N[\theta \circ (\psi \circ \epsilon)] \tag{$\beta$}\\
      &= I_N[(\theta \circ \psi) \circ \epsilon]\\
      &= N_1[\theta \circ \psi]
    \end{align*}
    Next we show $I_N$ is a right homomorphism, the typing here is
    $\phi : \alpha \to_{Q} \beta_1, \theta : \beta_1 \to_{\cat D}
    \beta_2$.
    \begin{align*}
      N_1[\theta] \circ I_N[\phi] &= I_N[\theta \circ \epsilon] \circ I_N[\phi]\\
      &= I_N[\theta \circ \epsilon \circ I_N[\phi]]\tag{left homomorphism}\\
      &= I_N[\theta \circ \phi] \tag{$\beta$}
    \end{align*}
    and to show $I_N^{-1}$ is a right homomorphism under $\phi : \alpha \to_{\cat C}N[\beta_1], \theta : \beta_1 \to_{\cat D} \beta_2$
    \begin{align*}
      I_N^{-1}[N_1[\theta] \circ \phi] &= \epsilon \circ (N_1[\theta] \circ \phi) \tag{def}\\
      &= \epsilon \circ (I_N[\theta \circ \epsilon] \circ \phi)\tag{def}\\
      &= (\epsilon \circ I_N[\theta \circ \epsilon]) \circ \phi\tag{assoc}\\
      &= (\theta \circ \epsilon) \circ \phi\tag{$\beta$}\\
      &= \theta \circ (\epsilon \circ \phi)\tag{assoc}\\
      &= \theta \circ I_N^{-1}[\phi] \tag{def}
    \end{align*}
  \end{enumerate}

  Next we need to show that this is a \emph{bijection}.
  \begin{enumerate}
  \item Starting with a negative type $N[\beta]$, we recover the
    original $\epsilon$ by the Yoneda lemma.
  \item Starting with a right representable $G[\beta]$, we recover the
    original $I_N^{-1}$ by the Yoneda lemma. We need to show that the
    action of $G$ on arrows is the same as the one defined from $G$
    viewed as a negative type, which we will call $G_1'$:
    \begin{align*}
      G_1'[\theta] &= I_G[\theta \circ \epsilon]\\
      &= G_1[\theta] \circ I_G[\epsilon]\tag{right homomorphism}\\
      &= G_1[\theta] \circ I_G[\epsilon \circ \id]\\
      &= G_1[\theta] \circ \id\\
      &= G_1[\theta]
    \end{align*}
  \end{enumerate}
\end{proof}

\subsection{Adjunctions by Universal Morphism}

As an example of formal category theory in our syntax, let's prove the
equivalence between two definitions of an adjunction: one by universal
morphism and the other by natural hom isomorphism.
%
Though the definitions and proof will look like we are doing ordinary
category theory, since it is syntactic it immediately applies to all
models, including enriched and internal category theory.

We start with the usual definition of an adjunction using
hom-isomorphism and a profunctor.
\begin{definition}
  Let $C,D$ be categories and $c^o:C_0,d:D_0 \vdash H[c,d]$ a
  profunctor between them. A \emph{left adjoint} to $H$ consists of
  \begin{enumerate}
  \item A functor $c:C \vdash F[c] : D$
  \item A natural isomorphism $c,d \pipe h : H[c,d] \vdash
    F_{ind}[h]: D_1[F_0[c],d]$. Call the inverse $g. F_{ind}^{-1}[g]$.
  \end{enumerate}
\end{definition}

\begin{definition}
  Let $c:C_0,d:D_0 \vdash H[c,d]$ be a profunctor.
  A \emph{universal $H$-heteromorphism from $C$} consists of
  \begin{enumerate}
  \item For every $c:C_0$, an $H$-morphism $\eta_c : H(c,F_0[c])$ for
    some function $c:C_0 \vdash F_0[c] : D_0$.
  \item Such that every $h : H[c,d]$ factors through $\eta_c$ in that
    there is a unique $h : H[c,d] \vdash F_{ind}[h] : D[F_0[c],d]$
    such that $h = F_{ind}[h] \circ \eta_c$.  Uniqueness means
    validity of the following rule:
    \begin{mathpar}
      \inferrule
      {g:D[F_0[c],d] \vdash g \circ \eta = h}
      {g:D[F_0[c],d] \vdash g = F_{ind}[h]}
    \end{mathpar}
    (Note that we do not require $F_{ind}$ to be natural in any sense)
  \end{enumerate}
\end{definition}

It is easy to see that a left adjoint gives a universal heteromorphism
by a Yoneda-like argument:
\begin{construction}
  Let $F$ be a left adjoint to $H$. Then we define a left universal
  $H$-heteromorphism by
  \begin{enumerate}
  \item $c \vdash \eta_c = F_{ind}^{-1}[\id[F_0[c]]]: H[c,F_0[c]]$
  \item Every $h : H[c,d]$ factorizes through $\eta$ because
    \begin{align*}
      F_{ind}[h] \circ F_{ind}^{-1}[\id] &= F_{ind}^{-1}[F_{ind}[h] \circ \id] \tag{naturality}\\
      &= F_{ind}^{-1}[F_{ind}[h]] \tag{unit}\\
      &= h \tag{isomorphism}
    \end{align*}
    This factorization is unique because if $g \circ F^{-1}[\id] = h$,
    then
    \begin{align*}
      F_{ind}[h] &= F_{ind}[g \circ F^{-1}[\id]] \tag{congruence}\\
      &= g \circ F_{ind}[F^{-1}[\id]] \tag{naturality}\\
      &= g \circ \id \tag{iso}\\
      &= g \tag{unit}
    \end{align*}
  \end{enumerate}
\end{construction}

But the utility of the universal morphism definition is that the
universal morphism extracted from a left adjoint is enough to uniquely
reconstruct the rest of the structure, which includes (1)
functoriality of $F$ and (2) naturality of $F_{ind}$.
\begin{construction}
  Let $(F_0,\eta,F_{ind}[h])$ be a left universal $H$-morphism.
  We extend this to a left adjoint as follows.
  \begin{enumerate}
  \item First, $F$ acts on morphisms by
    \begin{mathpar}
      \inferrule
      {
        \inferrule
         {f : C[c,c'] \and \eta_{c'} : H[c',F_0[c']]}
         {f : C[c,c'] \vdash \eta_{c'} \circ f : H[c,F_0[c']]}
      }
      {f : C[c,c'] \vdash F_{ind}[\eta_{c'} \circ f] : D[F_0[c],F_0[c']]}
    \end{mathpar}
    This preserves identity
    \begin{mathpar}
      \inferrule
      {
        \inferrule
        {\id \circ \eta = \eta}
        {\id = F_{ind}[\eta]}
      }
      {\id = F_{ind}[\eta \circ \id]}
    \end{mathpar}
    And composition
    \begin{mathpar}
      \inferrule
      {F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] \circ \eta = \eta \circ f \circ g}
      {F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] = F_{ind}[\eta \circ f \circ g]}
    \end{mathpar}
    Which follows by a couple uses of the factorization:
    \begin{align*}
      F_{ind}[\eta \circ f] \circ F_{ind}[\eta \circ g] \circ \eta
      &= F_{ind}[\eta \circ f] \circ \eta \circ g \\
      &= \eta \circ f \circ g
    \end{align*}
  \item Next, we show that $h : H[c,d] \vdash F_{ind}[h] :
    D[F_0[c],d]$ is a natural transformation. As a first step, we show
    that $\eta_c : H[c,F_0[c]]$ is natural in $c$ with the action of
    $F$ on morphisms we have just defined.
    \[ \eta \circ f = F[f] \circ \eta \]
    expanding the definition, this is precisely the factorization
    property:
    \[ \eta \circ f = F_{ind}[\eta \circ f] \circ \eta \]
    
    Next, to show that $F_{ind}$ is natural, we need to show that
    (when it is well-defined):
    \[F_{ind}[g \circ h \circ f] = g \circ F_{ind}[h] \circ F[f] \]
    By the factorization property, the following sufficeth:
    \begin{align*}
     g \circ F_{ind}[h] \circ F[f] \circ \eta
     &= g \circ F_{ind}[h] \circ \eta \circ f \tag{naturality of $\eta$}\\
     &= g \circ h \circ f \tag{factorization}
    \end{align*}
  \item Finally, we define $F_{ind}^{-1}[g]$ as
    \[ g : D[F_0[c],d] \vdash F_{ind}^{-1}[g] = g \circ \eta : H[c,d] \]
    And we need to confirm that it is (1) a section of $F_{ind}$ (2) a
    retraction of $F_{ind}$ and (3) natural.
    \begin{enumerate}
    \item For retraction we need to show $h \vdash F_{ind}[h] \circ
      \eta = h$ which is precisely the factorization property.
    \item For section, we need to show $g \vdash F_{ind}[g \circ \eta]
      = g$. Immediately the uniquenes principle says its sufficient to
      show $g \circ \eta = g \circ \eta$.
    \item For naturality, we need to show
      \[ F_{ind}^{-1}[k \circ g \circ F[f]] = k \circ F_{ind}^{-1}[g] \circ f \]
      expanding the definition this is just:
      \[ k \circ g \circ F[f] \circ \eta = k \circ g \circ \eta \circ f \]
      which is just naturality of $\eta$.
    \end{enumerate}
  \end{enumerate}
\end{construction}

\subsection{Products and Units of Internal Categories}

%% While we have now proved a beautiful internal theorem in great
%% generality that has many useful instances in different models, we are
%% hard pressed to actually \emph{instantiate} the theorem in the syntax
%% itself because we can't really come up with any useful universal properties!
%% The reason is that Judgment Theory itself is too bare-bones.

%% For instance how would we say that a category $\cat C$ has a
%% \emph{terminal object}? Well, it would have to be in the first place a
%% \emph{single} object in $\cat C$, but so far our syntax only enables
%% us to talk about functions and functors. Well an object of $\cat C$ is
%% the same as a function from the unit sort, but so far our syntax only
%% has base sorts.

%% So we see that defining the terminal object, \emph{necessitates} some
%% notion of terminal object in our ``metatheory'': Judgment Theory.
%% This mysterious and pervasive aspect of higher category theory is
%% called the \emph{microcosm principle} because it says that in order to
%% discuss a property of a single object in a single category (the
%% microcosm), we need the same sort of object at the meta-level (the
%% macrocosm). The adage here is ``As above, so below''.

%% That might all sound very spiritual, but we'll see that it's actually
%% quite a nice heuristic for formalizing universal properties in
%% internal category theory.
%% %
%% In the spirit of this heuristic, instead of first giving a bunch of
%% new type constructions for Judgment Theory and then applying them to
%% define universal properties, we will consider them in pairs, first
%% above, and then below.

First we consider the terminal sort and then the idea of a terminal
object in an internal category.

Next, the terminal sort trivially has a category structure using the
trivial judgment as its hom set:

\begin{definition}[Terminal Category]
  The terminal category $\cat 1$ consists of
  \begin{enumerate}
  \item Its object sort is $1$
  \item Its arrow judgment is $\alpha^o:1;\alpha:1 \pipe 1$
  \item Its identity arrow is given by $\alpha^o;\alpha \pipe \cdot \vdash () : 1$
  \item Composition is defined by $\phi : 1, \psi : 1 \vdash () : 1$
  \item Associativity and unitality are trivial by \textsc{1-$\eta$}
  \end{enumerate}
\end{definition}

\begin{definition}[Terminal Object Specification]
  In judgment type theory with a terminal sort/judgment, we can define
  for any category $\cat C$ a profunctor $\alpha^o:\cat C;\beta : \cat
  1 \pipe 1$, which specifies a terminal object.
\end{definition}

Now let's instantiate the definition for the terminal object defined
as a negative type and as a representable and see how it reproduces
the standard type-theoretic and category-theoretic definitions.

A representation of $\alpha^o:\cat C; \beta : \cat 1 \pipe 1$ consists
of a functor $\beta : \cat 1 \vdash 1_{\cat C} : \cat C$, an introduction rule
\[ \phi : 1 \vdash I_{1}[\phi] : \alpha \to_{\cat C} 1_{\cat C}[\beta] \]
satisfying $I_{1}[\phi] \circ \gamma =I_{1}[\phi \circ \gamma]$ and an
inverse $\psi : \alpha \to_{\cat C} 1_{\cat C}[\beta] \vdash
I_{1}^{-1}[\psi] : 1$ which by \textsc{1-$\eta$} is equal to $()$ and
therefore every $t : \alpha \to_{\cat C} 1_{\cat C}[\beta]$ is equal
to $I_{1}[\phi]$. In light of this it would be appropriate to write
$I_1[\phi]$ as $()$ and then the left-homomorphism property is $()
\circ \gamma = ()$, which is precisely the definition of substitution.

This alternate syntax makes even more sense in light of the negative
type presentation. A negative type satisfying the terminal object
specification consists of a functor $1_{\cat C}$ as above and an
introduction rule as above and an elimination form $\vdash \epsilon :
1$, which is trivial.

First the product category
\begin{definition}[Product category]
  For any categories $\cat C_1$, $\cat C_2$ we can form the product
  category whose sort of objects is $\cat C_1 \times \cat C_2$, whose
  arrow judgment is $\alpha^o : \cat C_1 \times \cat C_2;\alpha \pipe
  (\pi_1 \alpha \to_{\cat C_1} \pi_1 \alpha) \times (\pi_2 \alpha
  \to_{\cat C_2} \pi_2 \alpha)$. Identity is given by $\alpha^o : \cat
  C_1 \times \cat C_2;\alpha\pipe\cdot \vdash (\id_{\pi_1 \alpha},
  \id_{\pi_2 \alpha}) : (\pi_1 \alpha \to_{\cat C_1} \pi_1 \alpha)
  \times (\pi_2 \alpha \to_{\cat C_2} \pi_2 \alpha)$ and composition
  by
  \[
  \phi %: (\pi_1 \alpha_0 \to_{\cat C_1} \pi_1 \alpha_1) \times (\pi_2 \alpha_0 \to_{\cat C_2} \pi_2 \alpha_1)
  ,
  \psi %: (\pi_1 \alpha_1 \to_{\cat C_1} \pi_1 \alpha_2) \times (\pi_2 \alpha_1 \to_{\cat C_2} \pi_2 \alpha_2)
  \vdash ((\pi_1 \phi) \circ (\pi_1 \psi), (\pi_2 \psi) \circ (\pi_2 \phi)) :
  (\pi_1 \alpha_0 \to_{\cat C_1} \pi_1 \alpha_2) \times (\pi_2 \alpha_0 \to_{\cat C_2} \pi_2 \alpha_2)  
  \]
  unitality, associativity follow from the same properties of $\cat C_1,\cat C_2$
\end{definition}

\begin{definition}[Product Functor Specification]
  For any category $\cat C$, we can specify the product functor by
  \begin{enumerate}
  \item The span is $\alpha^o:\cat C; \beta : \cat C \times \cat C \pipe (\alpha \to_{\cat C} \pi_1 \beta) \times (\alpha \to_{\cat C} \pi_2 \beta)$
  \item Left Composition is defined as
    \[ \phi, \psi \vdash (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi)\]
  \item Left unitality:
    \begin{align*}
      (\pi_1 \phi \circ \id, \pi_2 \phi \circ \id)
      &= (\pi_1 \phi, \pi_2 \phi)\\
      &= \phi\tag{$\times-eta$}
    \end{align*}
  \item Left associativity:
    \begin{align*}
      (\phi \circ \psi) \circ \psi'
      &= (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi'\\
      &= (\pi_1 (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi',
      \pi_2 (\pi_1 \phi \circ \psi, \pi_2 \phi \circ \psi) \circ \psi')\\
      &= ((\pi_1 \phi \circ \psi) \circ \psi', (\pi_2 \phi \circ \psi) \circ \psi')\\
      &= (\pi_1 \phi \circ (\psi \circ \psi'), \pi_2 \phi \circ (\psi \circ \psi'))\\
      &= \phi \circ (\psi \circ \psi')
    \end{align*}
  \item Right composition is defined as
    \[ \phi, \theta \vdash (\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi) \]
  \item Right unitality:
    \begin{align*}
      (\pi_1 (\id,\id) \circ \pi_1 \phi, \pi_2 (\id,\id) \circ \pi_2 \phi)
      &= (\id \circ \pi_1 \phi, \id \circ \pi_2 \phi) \tag{$\times-\beta$}\\
      &= (\pi_1 \phi, \id \circ \pi_2 \phi)\\
      &= \phi \tag{$\times-\eta$}
    \end{align*}
  \item Right associativity
    \begin{align*}
      \theta' \circ (\theta \circ \phi)
      &= \theta' \circ (\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi)\\
      &= (\pi_1 \theta' \circ \pi_1(\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi),
      \pi_2 \theta' \circ \pi_2(\pi_1 \theta \circ \pi_1 \phi, \pi_2 \theta \circ \pi_2 \phi))\\
      &= (\pi_1 \theta' \circ (\pi_1 \theta \circ \pi_1 \phi), \pi_2 \theta' \circ (\pi_2 \theta \circ \pi_2 \phi))\\
      &= ((\pi_1 \theta' \circ \pi_1 \theta) \circ \pi_1 \phi, (\pi_2 \theta' \circ \pi_2 \theta) \circ \pi_2 \phi)\\
      &= (\pi_1(\theta' \circ \theta) \circ \pi_1 \phi, \pi_2(\theta' \circ \theta) \circ \pi_2 \phi)\\
      &= (\theta' \circ \theta) \circ \phi \\
    \end{align*}
  \end{enumerate}
\end{definition}

\subsection{Discrete and Codiscrete Categories}

If we have terminal judgments, then we can define the
\emph{codiscrete} category for any sort $\cat C$.
\begin{definition}
  The codiscrete category $\textrm{CoDisc} \cat C$ is defined as
  \begin{enumerate}
  \item Object sort is $\cat C$
  \item Morphisms judgment is $1$
  \item Identity and composition are given by the unique terms of
    those types, making associativity and unitality trivial to verify.
  \end{enumerate}
\end{definition}

If we have \emph{identity} objects, which we write as $\equiv_A$, then we
can define discrete categories.
\begin{definition}
  The discrete category $\textrm{Disc} \cat C$ is defined as
  \begin{enumerate}
  \item Object sort is $\cat C$
  \item Morphisms judgment is $\alpha;\alpha' \pipe \alpha \equiv \alpha'$
  \item Identity and composition are defined as in the section on
    synthetic category theory.
  \end{enumerate}
\end{definition}

\subsection{Internal Tensor, Cotensor}

We should be able to define internal \emph{tensor} using synthetic
tensor and coequalizers and also internal \emph{cotensor} using
synthetic cotensor and equalizers. These look exactly like the
set-theoretic definitions.
\begin{definition}
  Let $R$ be an internal profunctor from $C$ to $D$ and $S$ be an
  internal profunctor from $D$ to $E$.

  Then we can define the internal tensor product $R \odot S$, a
  profunctor from $C$ to $E$ as
  \begin{enumerate}
  \item The underlying span can be defined as a quotient of the synthetic tensor product
    \[ (R \odot S)[\alpha;\gamma] = \exists \beta:\cat D. R \odot S/Rcomp = Scomp \]

    Where R-comp and S-comp have as source the span
    \[ \exists \beta:\cat D.~ R[\alpha;\beta] \odot (\exists \beta':\cat D. Hom_C(\beta,\beta') \odot S[\beta';\gamma]) \]
    or the isomorphic
    \[ \exists \beta':\cat D.~ (\exists \beta:\cat D. R[\alpha;\beta] \odot Hom_C(\beta,\beta')) \odot S[\beta';\gamma] \]
    where R-comp composes the $C$-morphism with the $R$-morphism and
    S-comp the $S$-morphism.
  \item Composition is defined using composition in $R,S$.
  \end{enumerate}
\end{definition}
Note that $R$-comp and $S$-comp are each constructed using the 

\begin{definition}
  Let $R$ be an internal profunctor from $C$ to $D$ and $S$ be an
  internal profunctor from $C$ to $E$. Then the internal contravariant
  cotensor product $R \triangleright S$ is defined as
  \[ (R \triangleright S)[\beta;\gamma] = \{ p : \forall \alpha:\cat C.~ R[\alpha;\beta] \triangleright S[\alpha;\gamma] 
  \pipe R-comp = S-comp \}  \]
  R-comp and S-comp have as codomain the span
  \[ \forall \alpha:\cat C.~ R[\alpha;\beta] \triangleright \forall \alpha':\cat C.~ Hom_C(\alpha',\alpha) \triangleright S[\alpha';\gamma] \]
  or the isomorphic
  \[ \forall \alpha':\cat C.~ (\exists \alpha. Hom_C(\alpha',\alpha) \odot R[\alpha;\beta]) \triangleright S[\alpha';\gamma]
  \]
\end{definition}

We can also construct the \emph{free profunctor} from a span using tensor:

\begin{definition}
  Let $\cat C$ and $\cat D$ be internal categories and let $R[\alpha;\beta]$ be a
  span from $Ob(\cat C)$ to $Ob(\cat D)$. Then the free profunctor
  extending $R$ to be an internal profunctor from $\cat C$ to $\cat D$ is
  \[ F_{\cat C,\cat D}R[\alpha';\beta'] = \exists \alpha. Hom_C(\alpha',\alpha) \odot (\exists \beta. R[\alpha;\beta] \odot Hom_C(\beta,\beta')) \]
  or the isomorphic
  \[ F_{\cat C,\cat D}R[\alpha';\beta'] = \exists \beta. (\exists \alpha. Hom_C(\alpha',\alpha) \odot R[\alpha;\beta]) \odot Hom_C(\beta,\beta') \]
\end{definition}

And maybe we can even define the co-free profunctor from a span using cotensor?
\begin{definition}
  Let $\cat C$ and $\cat D$ be internal categories and let $R[\alpha;\beta]$ be a
  span from $Ob(\cat C)$ to $Ob(\cat D)$. Then the co-free profunctor
  extending $R$ to be an internal profunctor from $\cat C$ to $\cat D$ is
  \[ G_{\cat C,\cat D}R[\alpha';\beta'] =
  \forall \alpha. Hom_C(\alpha,\alpha') \triangleright (\forall \beta. R[\alpha;\beta] \triangleleft Hom_D(\beta',\beta)) \]
  or the isomorphic
  \[ G_{\cat C,\cat D}R[\alpha';\beta'] =
  \forall \beta. 
  (\forall \alpha. Hom_C(\alpha,\alpha') \triangleright R[\alpha;\beta]) \triangleleft Hom_D(\beta',\beta)) \]
\end{definition}

\section{Synthetic Category Theory}

Next, we look at Synthetic category theory in a virtual equipment. In
this section we will use category-theoretic terminology for judgment
theory: categories, functors/objects, profunctors and transformations.

\subsection{Constructions: Categories, Functors and Natural Transformations}

Hom sets don't provide primitive syntax for composition of morphisms
in a category. As our first synthetic construction, we can
\emph{define} composition using the elimination form.
%
\begin{definition}[Composition of Morphisms]
  We define composition of morphisms as follows
  \[
  f : \beta \to_{\cat C} \beta', g : \beta' \to_{\cat C} \beta'' \vdash g \circ f :=
  \when f = \id_{\beta}.~ \when g = \id_{\beta}.~ \id_{\beta} : \beta \to_{\cat c} \beta''
  \]
\end{definition}
It should follow by $\beta\eta$ that this is associative and unital.

Next, let's prove synthetically that every type $\alpha : \cat C
\vdash A : \cat D$ is in fact functorial.
\begin{definition}
  There is a morphism
  \[ \alpha^o:\cat C;\alpha':\cat C \vdash f : \alpha \to_{\cat C} \alpha' \vdash
  \when f = \id_{\alpha}.~ \id_{A} : A[\alpha] \to_{\cat D} A[\alpha']
  \]
  which we call $A[f/\alpha]$.

  Note that
  \[ A[\id_\alpha/\alpha] = \id_{A} \]
  \[ A[f;g] = A[f];A[g] \]
\end{definition}
Note the similarity to the proof that all functions are congruences in
MLTT/HoTT.

Next we can define natural transformations as specific kinds of
terms whose type is $(F \alpha \to G \alpha')$.
\begin{definition}
  A natural transformation $\phi$ from $\alpha : \cat C \vdash A : \cat D$ to
  $A'[\alpha]$ of the same type is a term
  \[ \alpha\pipe \cdot \vdash \phi_\alpha : A[\alpha] \to_{\cat D} A'[\alpha] \]

  Note that
  \[ \alpha;\alpha' \pipe f : \alpha \to \alpha' \vdash
  f \circ \phi_{\alpha} = \phi_{\alpha'} \circ f
  \]
  Because if $f$ is the identity, then both sides are the same.
\end{definition}

\subsection{Adjoint Functors}

There are two common definitions of adjoint functors, one in terms of
Hom-sets and one in terms of units and counits.

\begin{definition}
  A functor $\alpha : \cat C \vdash L : \cat D$ is left adjoint to a
  functor $\beta : \cat D \vdash R : \cat C$ if there is an isomorphism
  \[ (L[\alpha] \to_{\cat D} \beta) \cong (\alpha \to_{\cat C} R[\beta]) \]

  Alternatively, $L$ is left adjoint to $R$ if there exist
  transformations
  \[ \eta : \alpha \to_{\cat C} R[L[\alpha]/\beta] \] % unit of the monad 1 -> RL 
  \[ \epsilon : L[R[\beta]/\alpha] \to_{\cat D} \beta  \] % counit of the comonad LR -> 1
  satisfying the triangle/zig-zag identities
  \[ \id_{R[\beta]} = R[\epsilon_{\beta}] \circ \eta_{R[\beta]} \]
  \[ \id_{L[\alpha]} = \epsilon_{L[\alpha]} \circ L[\eta_{\alpha}] \]
\end{definition}

We should be able to synthetically prove these are equivalent.

\subsection{Tensors and CoTensors/Powers}

David Jaz Myers tells me that to do all of formal category theory in
an equipment, you just need to have hom sets, tensors and cotensors.

As another example synthetic theorem, we can prove the covariant and
contravariant \emph{co-yoneda lemmas}, which are precisely the
statement that Hom is the unit of the tensor product.
\begin{lemma}[CoYoneda]
  We can define isomorphisms
  \[ \exists \beta. (\alpha \to_{\cat C} \beta) \odot Q \equiv Q[\alpha/\beta] \]
  \[ \exists \beta. P \odot (\beta \to_{\cat C} \gamma) \equiv P[\gamma/\beta] \]
  The forward direction is defined by considering the case that the
  function is the identity and the backward direction by using the
  identity.
\end{lemma}
\begin{proof}
  The terms are
  \[ f : \exists \beta. (\alpha\to_{\cat C} \beta) \odot Q \vdash
  \lett (\beta,g,h) = f.~ \when g = \id_{\alpha}.~ h : Q[\alpha/\beta]
  \]
  And the inverse
  \[ h : Q[\alpha/\beta] \vdash (\alpha, \id_{\alpha}, h) : \exists \beta. (\alpha\to_{\cat C}\beta)\odot Q\]

  One direction of iso follows by $\beta$, the other by $\eta$.
\end{proof}

And we get another synthetic theorem: the Yoneda lemma, which says
that Hom is the unit for the cotensor product.
\begin{lemma}[Synthetic Yoneda]
  We can define isomorphisms
  \[ \forall \alpha.~ (\alpha \to \beta) \triangleright P[\alpha;\gamma] \cong P[\beta/\alpha;\gamma] \]
  \[ \forall \gamma.~ P[\alpha;\gamma] \triangleleft (\beta \to \gamma) \cong P[\alpha;\beta/\gamma]\]
\end{lemma}
\begin{proof}
  Forward direction
  \[ f : \forall \alpha.~(\alpha\to\beta)\triangleright P \vdash
  f(\beta,\id_{\beta})^\triangleright : P[\beta/\alpha]
  \]
  Backwards
  \[ x : P[\beta/\alpha]\vdash
  \lambda^\triangleright(\alpha,\phi : \alpha \to \beta).~\when \phi = \id_{\beta}.~ x : \forall \alpha. (\alpha\to \beta) \triangleright P
  \]
  One direction is by $\beta$, the other $\eta$.
\end{proof}

\subsection{Kan Extensions}

I \emph{think} this is the right way to define left and right Kan
extensions using tensor/cotensor.

The right Kan extension of $F$ along $J$ is the best way to fill in the following square:
\[% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEQBfU9TXfIRQBGclVqMWbACLdeIDNjwEiZYePrNWiDgHJu4mFADm8IqABmAJwgBbJGRA4ISAEzVNUnQCk5lm-aIjs5IohJabABiBlxAA
\begin{tikzcd}
C \arrow[d, "J"] \arrow[r, "F"] & D \\
C'                              &  
\end{tikzcd}\]
I.e. a functor $Ran_J F : C' \to D$ that is universal something something.

If $D$ is complete, there is a formula using ends for this. Using
cotensor, we can directly adapt this to define a \emph{profunctor}
that is a universal filler. We can then say that a right Kan extension
is a functor that represents this profunctor.

\begin{definition}
  Let $\cat C, \cat C', \cat D$ be categories and let $\alpha : \cat C
  \vdash A : \cat D$ and $\alpha : \cat C \vdash J : \cat C'$ be
  functors. Then the right Kan extension profunctor is a profunctor
  $\beta^o:\cat D; \gamma:\cat C' \pipe (RPan_J A)[\beta;\gamma]$ which we can define as
  \[ \beta^o:\cat D; \gamma:\cat C' \pipe (RPan_J A)[\beta;\gamma] = \forall \alpha:\cat C.~ (\beta \to_{\cat D} A) \triangleleft (\gamma \to_{\cat C'} J)
  \]
  A right Kan extension is then a functor $\gamma:\cat C' \vdash
  Ran_J[\alpha] : \cat D$ that represents $RPan_J A$ in that
  \[ (\beta \to_{\cat D} Ran_J[\gamma]) \cong (RPan_J A)[\beta;\gamma] \]
\end{definition}

If we have a unit type, then we can now define limits as a special
case.
\begin{definition}
  The limit of a functor $\alpha : \cat C \vdash A : \cat D$ is the
  right Kan extension of $A$ along $\alpha : \cat C \vdash () : 1$.

  Unraveling the definition this means
  \[ (\beta \to_{\cat D} \lim_\alpha A) \cong \forall \alpha:\cat C.~ (\beta \to_{\cat D} A) \triangleleft (\gamma \to_{1} ()) \]
\end{definition}
Since morphisms in $1$ are trivial, we can almost directly read this
as saying that a morphism into a limit of a functor is precisely a
cone: for every $\alpha$, a morphism from $\beta$ to $A[\alpha]$. The
side condition of naturality of this family is automatically
satisfied.

We can also define a left Kan extensions using the contravariant
cotensors.  Normally the left Kan extension is defined using tensors,
but the definition using profunctors doesn't look right to me. Let's
work backwards from the definition of colimit to see why.

Let $\alpha : \cat C \vdash A : \cat D$ be a functor we want the
colimit of. The UP of a colimit is that maps out of it are equivalent
to cocones from $A$. Semi-formally this looks like
\[ (\colim_{\alpha} A \to_{\cat D} \beta) \cong \forall \alpha:\cat C.~ A \to_{\cat D} \beta \]
This looks a lot like a cotensor with a trivial domain:
\[ (\colim_{\alpha} A \to_{\cat D} \beta) \cong \forall \alpha. (() \to_{1} \gamma) \triangleright (A \to_{\cat D} \beta) \]
Suggesting that we define the left Kan extension profunctor as a
contravariant cotensor as follows.
\begin{definition}
  Let $\cat C,\cat C',\cat D$ be cats and let $\alpha:\cat C \vdash A
  : \cat D$ and $\alpha : \cat C \vdash J : \cat C'$ be functors.
  Then the left Kan extension profunctor $\gamma^o:\cat C'; \beta:\cat
  D \pipe (PLan_J A)[\gamma;\beta]$ is defined as
  \[
  \gamma^o:\cat C'; \beta:\cat D \pipe (PLan_J A)[\gamma;\beta]
  := \forall \alpha : \cat C.~ (J \to_{\cat C'} \gamma) \triangleright (A \to_{\cat D} \beta)
  \]
  Then a left Kan extension of $A$ along $J$ is a functor $\gamma :
  \cat C' \vdash Lan_J A : \cat D$ that represents $PLan_J A$ in that
  \[ (Lan_J A \to_{\cat D} \beta) \cong (LPan_J A)[\gamma;\beta] \]
\end{definition}


%% \begin{definition}
  %% Let $\cat C,\cat C',\cat D$ be cats and let $\alpha:\cat C \vdash
  %% : \cat D$ and $\alpha : \cat C \vdash J : \cat C'$ be functors.
  %% Then the left Kan extension profunctor $\beta^o:\cat D; \gamma:\cat
  %% C' \pipe (PLan_J F)[\beta;\gamma]$ is defined as
%%   \[
%%   \beta^o:\cat D; \gamma:\cat C' \pipe (PLan_J A)[\beta;\gamma] :=
%%   \exists \alpha:\cat C. (\beta \to_{\cat D} A[\alpha]) \odot (J[\alpha] \to_{\cat C'} \gamma)
%%   \]
%%   And a left Kan extension is a functor $\gamma :\cat C' \vdash Lan_J
%%   A : \cat D$ that represents $PLan_J A$ in that
%%   \[ (\beta \to_{\cat D} Lan_J A[\alpha]) \cong (PLan_J A)[\beta;\alpha] \]
%% \end{definition}

\subsection{Right (Left) Adjoints preserve (co-)Limits}

Let's prove that classic theorem!

\begin{theorem}
  Let $\alpha : \cat C \vdash A \cat D$ be an arbitrary functor and
  $\beta : \cat D \vdash R : \cat E$ be a functor with a left adjoint
  $L$. Then, if the limit $\lim_\alpha A$ exists, then $\lim_\alpha
  R[A/\beta]$ also exists and is
  \[ \lim_\alpha R[A/\beta] = R[\lim_\alpha A] \]
\end{theorem}
\begin{proof}
  We need to give an isomorphism
  \[ \gamma \to R[\lim_\alpha A/\beta] \cong PRan_{()}{\alpha. R[A/\beta]} = \forall \alpha. (\gamma \to R[A/\beta]) \triangleleft (() \to_1 ()) \]
  By assumption we have an isomorphism
  \[ l : \beta \to \lim_\alpha A \cong PRan_{()}{\alpha. A} = \forall \alpha. (\beta \to A[\alpha]) \triangleleft (()\to_1 ())\]
  TODO.
\end{proof}

\subsection{Additive Facts}

I think the following isomorphisms should hold, which connect additive
connectives on objects with the analogous connective on profunctors:
\[ () \to_1 () \cong () \]
\[ (\pi_1 \alpha, \pi_2 \alpha) \to_{\cat C \times \cat D} (\pi_1 \beta, \pi_2 \beta) \cong
((\pi_1 \alpha) \to_{\cat C} (\pi_1 \beta)) \times ((\pi_2 \alpha) \to_{\cat C} (\pi_2 \beta)) \]

\section{Implementation Concerns}

So far all of the theorems we have presented are \emph{metatheorems},
constructing some terms in our theory given some other terms we've
alread constructed. For instance, for any collection of terms that
defines an internal category, we can define another collection of
terms that defines the identity functor from that category to
itself. We would prefer to make this process a formal syntactic
construction so that we can take advantage of an automatic type
checker for our syntax. There are two obvious choices for this: first,
we can formalize the syntax of judgment theory using a proof assistant
such as Coq or Agda and define these as metatheorems essentially as we
have done so far. Alternatively, we can define a \emph{domain
  specific} proof assistant that extends judgment theory with a kind
of \emph{module system} that enables us to define theorems and
constructions fully formally. Such a module system could itself be
defined in a proof assistant and its theorems internalized there. An
advantage of the syntactic approach is that we should get out more
than we put in: modules should be automatically \emph{homomorphisms}
in some sense with respect to models (though I'm not sure yet how).
This should be closely related to the initiality theorem for the
syntax.

In programming language terminology, we have defined an
\emph{expression language} and we now want to define on top of that a
\emph{definition language} or \emph{module system}.
%
First, we define a signature context $\Gamma$. In programming terms,
we should think of this as the context of top-level definitions.
%
And we need to extend our expression language syntax as well to
include references to the current signature context.

To a first approximation, we can define signature contexts as
follows. This is likely how we will define signatures in the
initiality theorem.
\begin{mathpar}
  \inferrule*[right=Signature Ctx Formation]
  {}
  {\Gamma \sigctx}

  \inferrule*[right=SigCtx Base Sort]
  {\Gamma \sigctx}
  {\Gamma , X \sigctx}

  \inferrule*[right=Sort Base]
  {\Gamma \ni X}
  {\Gamma \vdash X \sort}

  \inferrule*[right=SigCtx Function Symbol]
  {\Gamma \sigctx \and
    \Gamma \vdash \cat C\sort\and
    \Gamma \vdash \cat D \sort    
  }
  {\Gamma , f : \cat C \to \cat D \sigctx}

  \inferrule*[right=Type Function Symbol]
  {\Gamma \ni f : \cat D \to \cat E
  \and x : \cat C \vdash A : \cat D}
  {\Gamma \pipe x:\cat C \vdash f(A) : \cat E}

  \inferrule
  {\Gamma \sigctx \and \Gamma \vdash \cat C \sort \and \Gamma \vdash \cat D \sort}
  {\Gamma, R : \cat C \nrightarrow \cat D \sigctx}

  \inferrule
  {\Gamma \ni R : \cat C \nrightarrow \cat D \and
    \Gamma \pipe \alpha' :\cat C' \vdash A : \cat C\and
    \Gamma \pipe \beta' :\cat D' \vdash B : \cat D}
  {\Gamma\pipe \alpha'^o:\cat C';\beta'^o:\cat D' \pipe R(A,B) }

  \cdots
\end{mathpar}

But in our implementation we will also include \emph{named modules}
and \emph{named signatures}, in which case we will have record
selectors to refer to assumptions, not just names.

Maybe $\Gamma$s include signature and module definitions, but
$\Delta$s include only ``primitive'' definitions?
\begin{mathpar}
  % Signatures should be either parameterized signatures (possibly empty parameter set)
  % or Signature references (for aliasing purposes)
  \inferrule
  {\Gamma, \Delta, \Delta' \sig}
  {\Gamma , S = \textrm{signature} (\Delta) \{ \Delta' \} \sigctx}

  % modules should either be parameterized modules or module
  % references.
  \inferrule
  {}
  {\Gamma , M = \textrm{module}(\Delta) \{ \Xi \}}

  % the top level of a program is a module
\end{mathpar}

%% \subsection{Module System}

%% Currently, the theorems presented in \ref{internal} were all
%% metatheorems, we can give them a \emph{formal} status by incorporating
%% a simple module system on top of span theory.
%% %
%% This serves as the basis for a \emph{domain specific proof assistant}
%% for category theory that we plan to use to teach category theory.

%% \subsection{Semantics of Judgment Theory}

%% We should have soundness and completeness theorems for the
%% interpretation of Judgment Theory in virtual equipments (with the
%% corresponding UPs of Hom/Tensor/cotensor/products etc).

\end{document}

%% Local Variables:
%% compile-command: "pdflatex syntax.tex"
%% End:
